Index: apg.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package main\r\n\r\nimport (\r\n\t\"crypto/rand\"\r\n\t\"flag\"\r\n\t\"fmt\"\r\n\t\"math/big\"\r\n\t\"os\"\r\n\t\"regexp\"\r\n)\r\n\r\n// Constants\r\nconst DefaultPwLenght int = 20\r\nconst VersionString string = \"0.2.3\"\r\nconst PwLowerCharsHuman string = \"abcdefghjkmnpqrstuvwxyz\"\r\nconst PwUpperCharsHuman string = \"ABCDEFGHJKMNPQRSTUVWXYZ\"\r\nconst PwLowerChars string = \"abcdefghijklmnopqrstuvwxyz\"\r\nconst PwUpperChars string = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\r\nconst PwSpecialCharsHuman string = \"\\\"#%*+-/:;=\\\\_|~\"\r\nconst PwSpecialChars string = \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\"\r\nconst PwNumbersHuman string = \"23456789\"\r\nconst PwNumbers string = \"1234567890\"\r\n\r\ntype cliOpts struct {\r\n\tminPassLen    int\r\n\tmaxPassLen    int\r\n\tnumOfPass     int\r\n\tuseComplex    bool\r\n\tuseLowerCase  bool\r\n\tuseUpperCase  bool\r\n\tuseNumber     bool\r\n\tuseSpecial    bool\r\n\thumanReadable bool\r\n\texcludeChars  string\r\n\tshowHelp      bool\r\n\tshowVersion   bool\r\n}\r\n\r\nvar config cliOpts\r\n\r\n// Read flags\r\nfunc init() {\r\n\t// Bool flags\r\n\tflag.BoolVar(&config.useLowerCase, \"L\", true, \"Use lower case characters in passwords\")\r\n\tflag.BoolVar(&config.useUpperCase, \"U\", false, \"Use upper case characters in passwords\")\r\n\tflag.BoolVar(&config.useNumber, \"N\", false, \"Use numbers in passwords\")\r\n\tflag.BoolVar(&config.useSpecial, \"S\", false, \"Use special characters in passwords\")\r\n\tflag.BoolVar(&config.useComplex, \"C\", true, \"Generate complex passwords (implies -L -U -N -S, disables -H)\")\r\n\tflag.BoolVar(&config.humanReadable, \"H\", false, \"Generate human-readable passwords\")\r\n\tflag.BoolVar(&config.showVersion, \"v\", false, \"Show version\")\r\n\r\n\t// Int flags\r\n\tflag.IntVar(&config.minPassLen, \"m\", 10, \"Minimum password length\")\r\n\tflag.IntVar(&config.maxPassLen, \"x\", DefaultPwLenght, \"Maxiumum password length\")\r\n\tflag.IntVar(&config.numOfPass, \"n\", 1, \"Number of passwords to generate\")\r\n\r\n\t// String flags\r\n\tflag.StringVar(&config.excludeChars, \"E\", \"\", \"Exclude list of characters from generated password\")\r\n\r\n\tflag.Parse()\r\n\tif config.showVersion {\r\n\t\t_, _ = os.Stderr.WriteString(\"Winni's Advanced Password Generator Clone (apg.go) v\" + VersionString + \"\\n\")\r\n\t\tos.Exit(0)\r\n\t}\r\n}\r\n\r\n// Main function that generated the passwords and returns them\r\nfunc main() {\r\n\tpwLength := config.minPassLen\r\n\tif pwLength < config.minPassLen {\r\n\t\tpwLength = config.minPassLen\r\n\t}\r\n\tif pwLength > config.maxPassLen {\r\n\t\tpwLength = config.maxPassLen\r\n\t}\r\n\tif config.useComplex {\r\n\t\tconfig.useUpperCase = true\r\n\t\tconfig.useLowerCase = true\r\n\t\tconfig.useSpecial = true\r\n\t\tconfig.useNumber = true\r\n\t\tconfig.humanReadable = false\r\n\t}\r\n\r\n\tcharRange := getCharRange()\r\n\r\n\tfor i := 1; i <= config.numOfPass; i++ {\r\n\t\tpwString, err := getRandChar(&charRange, pwLength)\r\n\t\tif err != nil {\r\n\t\t\tfmt.Printf(\"getRandChar returned an error: %q\\n\", err.Error())\r\n\t\t\tos.Exit(1)\r\n\t\t}\r\n\t\tfmt.Println(pwString)\r\n\t}\r\n}\r\n\r\n// Provide the range of available characters based on provided parameters\r\nfunc getCharRange() string {\r\n\tpwUpperChars := PwUpperChars\r\n\tpwLowerChars := PwLowerChars\r\n\tpwNumbers := PwNumbers\r\n\tpwSpecialChars := PwSpecialChars\r\n\tif config.humanReadable {\r\n\t\tpwUpperChars = PwUpperCharsHuman\r\n\t\tpwLowerChars = PwLowerCharsHuman\r\n\t\tpwNumbers = PwNumbersHuman\r\n\t\tpwSpecialChars = PwSpecialCharsHuman\r\n\t}\r\n\r\n\tvar charRange string\r\n\tif config.useLowerCase {\r\n\t\tcharRange = charRange + pwLowerChars\r\n\t}\r\n\tif config.useUpperCase {\r\n\t\tcharRange = charRange + pwUpperChars\r\n\t}\r\n\tif config.useNumber {\r\n\t\tcharRange = charRange + pwNumbers\r\n\t}\r\n\tif config.useSpecial {\r\n\t\tcharRange = charRange + pwSpecialChars\r\n\t}\r\n\tif config.excludeChars != \"\" {\r\n\t\tregExp := regexp.MustCompile(\"[\" + config.excludeChars + \"]\")\r\n\t\tcharRange = regExp.ReplaceAllLiteralString(charRange, \"\")\r\n\t}\r\n\r\n\treturn charRange\r\n}\r\n\r\n// Generate random characters based on given character range\r\n// and password length\r\nfunc getRandChar(charRange *string, pwLength int) (string, error) {\r\n\tif pwLength <= 0 {\r\n\t\terr := fmt.Errorf(\"provided pwLength value is <= 0: %v\", pwLength)\r\n\t\treturn \"\", err\r\n\t}\r\n\tavailCharsLength := len(*charRange)\r\n\tcharSlice := []byte(*charRange)\r\n\treturnString := make([]byte, pwLength)\r\n\tfor i := 0; i < pwLength; i++ {\r\n\t\trandNum, err := getRandNum(availCharsLength)\r\n\t\tif err != nil {\r\n\t\t\treturn \"\", err\r\n\t\t}\r\n\t\treturnString[i] = charSlice[randNum]\r\n\t}\r\n\treturn string(returnString), nil\r\n}\r\n\r\n// Generate a random number with given maximum value\r\nfunc getRandNum(maxNum int) (int, error) {\r\n\tif maxNum <= 0 {\r\n\t\terr := fmt.Errorf(\"provided maxNum is <= 0: %v\", maxNum)\r\n\t\treturn 0, err\r\n\t}\r\n\tmaxNumBigInt := big.NewInt(int64(maxNum))\r\n\tif !maxNumBigInt.IsUint64() {\r\n\t\terr := fmt.Errorf(\"big.NewInt() generation returned negative value: %v\", maxNumBigInt)\r\n\t\treturn 0, err\r\n\t}\r\n\trandNum64, err := rand.Int(rand.Reader, maxNumBigInt)\r\n\tif err != nil {\r\n\t\treturn 0, err\r\n\t}\r\n\trandNum := int(randNum64.Int64())\r\n\tif randNum < 0 {\r\n\t\terr := fmt.Errorf(\"generated random number does not fit as int64: %v\", randNum64)\r\n\t\treturn 0, err\r\n\t}\r\n\treturn randNum, nil\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/apg.go b/apg.go
--- a/apg.go	(revision 46e47348e28ef2c222c7ae3c1b7cb9e9ed9b2a22)
+++ b/apg.go	(date 1616331345028)
@@ -1,17 +1,15 @@
 package main
 
 import (
-	"crypto/rand"
 	"flag"
 	"fmt"
-	"math/big"
 	"os"
 	"regexp"
 )
 
 // Constants
 const DefaultPwLenght int = 20
-const VersionString string = "0.2.3"
+const VersionString string = "0.2.4"
 const PwLowerCharsHuman string = "abcdefghjkmnpqrstuvwxyz"
 const PwUpperCharsHuman string = "ABCDEFGHJKMNPQRSTUVWXYZ"
 const PwLowerChars string = "abcdefghijklmnopqrstuvwxyz"
@@ -32,6 +30,7 @@
 	useSpecial    bool
 	humanReadable bool
 	excludeChars  string
+	newStyleModes string
 	showHelp      bool
 	showVersion   bool
 }
@@ -56,6 +55,8 @@
 
 	// String flags
 	flag.StringVar(&config.excludeChars, "E", "", "Exclude list of characters from generated password")
+	flag.StringVar(&config.newStyleModes, "M", "",
+		"New style password parameters (higher priority than single parameters)")
 
 	flag.Parse()
 	if config.showVersion {
@@ -80,6 +81,17 @@
 		config.useNumber = true
 		config.humanReadable = false
 	}
+	if config.newStyleModes != "" {
+		parseNewStyleParams()
+	}
+
+	if config.useUpperCase == false &&
+		config.useLowerCase == false &&
+		config.useNumber == false &&
+		config.useSpecial == false {
+		fmt.Printf("No password mode set. Cannot generate password from empty character set.")
+		os.Exit(1)
+	}
 
 	charRange := getCharRange()
 
@@ -127,45 +139,50 @@
 	return charRange
 }
 
-// Generate random characters based on given character range
-// and password length
-func getRandChar(charRange *string, pwLength int) (string, error) {
-	if pwLength <= 0 {
-		err := fmt.Errorf("provided pwLength value is <= 0: %v", pwLength)
-		return "", err
-	}
-	availCharsLength := len(*charRange)
-	charSlice := []byte(*charRange)
-	returnString := make([]byte, pwLength)
-	for i := 0; i < pwLength; i++ {
-		randNum, err := getRandNum(availCharsLength)
-		if err != nil {
-			return "", err
+// Parse the new style parameters
+func parseNewStyleParams() {
+	for _, curParam := range config.newStyleModes {
+		switch curParam {
+		case 'S':
+			config.useSpecial = true
+			break
+		case 's':
+			config.useSpecial = false
+			break
+		case 'N':
+			config.useNumber = true
+			break
+		case 'n':
+			config.useNumber = false
+			break
+		case 'L':
+			config.useLowerCase = true
+			break
+		case 'l':
+			config.useLowerCase = false
+			break
+		case 'U':
+			config.useUpperCase = true
+			break
+		case 'u':
+			config.useUpperCase = false
+			break
+		case 'H':
+			config.humanReadable = true
+			break
+		case 'h':
+			config.humanReadable = false
+			break
+		// APG compatbilitly
+		case 'C':
+			config.useUpperCase = true
+			break
+		case 'c':
+			config.useUpperCase = false
+			break
+		default:
+			fmt.Printf("Unknown password style parameter: %q\n", string(curParam))
+			os.Exit(1)
 		}
-		returnString[i] = charSlice[randNum]
 	}
-	return string(returnString), nil
-}
-
-// Generate a random number with given maximum value
-func getRandNum(maxNum int) (int, error) {
-	if maxNum <= 0 {
-		err := fmt.Errorf("provided maxNum is <= 0: %v", maxNum)
-		return 0, err
-	}
-	maxNumBigInt := big.NewInt(int64(maxNum))
-	if !maxNumBigInt.IsUint64() {
-		err := fmt.Errorf("big.NewInt() generation returned negative value: %v", maxNumBigInt)
-		return 0, err
-	}
-	randNum64, err := rand.Int(rand.Reader, maxNumBigInt)
-	if err != nil {
-		return 0, err
-	}
-	randNum := int(randNum64.Int64())
-	if randNum < 0 {
-		err := fmt.Errorf("generated random number does not fit as int64: %v", randNum64)
-		return 0, err
-	}
-	return randNum, nil
-}
+}
\ No newline at end of file
Index: rand.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rand.go b/rand.go
new file mode 100644
--- /dev/null	(date 1616331340961)
+++ b/rand.go	(date 1616331340961)
@@ -0,0 +1,50 @@
+package main
+
+import (
+	"crypto/rand"
+	"fmt"
+	"math/big"
+)
+
+// Generate random characters based on given character range
+// and password length
+func getRandChar(charRange *string, pwLength int) (string, error) {
+	if pwLength <= 0 {
+		err := fmt.Errorf("provided pwLength value is <= 0: %v", pwLength)
+		return "", err
+	}
+	availCharsLength := len(*charRange)
+	charSlice := []byte(*charRange)
+	returnString := make([]byte, pwLength)
+	for i := 0; i < pwLength; i++ {
+		randNum, err := getRandNum(availCharsLength)
+		if err != nil {
+			return "", err
+		}
+		returnString[i] = charSlice[randNum]
+	}
+	return string(returnString), nil
+}
+
+// Generate a random number with given maximum value
+func getRandNum(maxNum int) (int, error) {
+	if maxNum <= 0 {
+		err := fmt.Errorf("provided maxNum is <= 0: %v", maxNum)
+		return 0, err
+	}
+	maxNumBigInt := big.NewInt(int64(maxNum))
+	if !maxNumBigInt.IsUint64() {
+		err := fmt.Errorf("big.NewInt() generation returned negative value: %v", maxNumBigInt)
+		return 0, err
+	}
+	randNum64, err := rand.Int(rand.Reader, maxNumBigInt)
+	if err != nil {
+		return 0, err
+	}
+	randNum := int(randNum64.Int64())
+	if randNum < 0 {
+		err := fmt.Errorf("generated random number does not fit as int64: %v", randNum64)
+		return 0, err
+	}
+	return randNum, nil
+}
